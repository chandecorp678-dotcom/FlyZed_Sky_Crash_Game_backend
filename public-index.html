<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ka Ndeke ‚Äì Aviator (fixed)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    body { margin: 0; font-family: Arial, sans-serif; background: #081a2b; color: #fff; text-align: center; }
    header { background: #03101f; padding: 10px; display: flex; justify-content: space-between; align-items: center; }
    header h1 { margin: 0; font-size: 18px; color: gold; }
    header .right { display: flex; gap: 8px; align-items: center; }
    header button { margin-left: 5px; }
    button { padding: 8px 14px; border-radius: 4px; border: none; cursor: pointer; }
    .primary { background: gold; color: #000; font-weight: bold; }
    .danger { background: crimson; color: #fff; }
    .panel { padding: 10px; }
    .game-box { background: #12345a; margin: 10px; border-radius: 10px; padding: 10px; height: 260px; position: relative; overflow: hidden; }
    #multiplier { font-size: 26px; font-weight: bold; position: absolute; top: 10px; left: 10px; }
    #plane { width: 80px; position: absolute; bottom: 20px; left: 10px; transition: transform 0.08s linear; }
    input { padding: 8px; width: 120px; text-align: center; }
    .controls { margin-top: 10px; }
    .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 1000; }
    .modal-content { background: #0c223a; padding: 20px; width: 95%; max-width: 420px; border-radius: 8px; color: #fff; }
    .modal-content h3 { margin-top: 0; }
    .modal-content input { width: 100%; margin-bottom: 10px; padding: 8px; color: #fff; background: #0b1b33; border: 1px solid #444; border-radius: 4px; }
    .hidden { display: none; }
    .flex { display:flex; gap:8px; align-items:center; justify-content:center; }
    .history-list { max-height: 320px; overflow:auto; text-align:left; margin-top:10px; }
    .history-item { padding:8px; border-radius:6px; margin-bottom:6px; background: rgba(255,255,255,0.02); cursor:pointer; }
    .small { font-size: 12px; color: #cfe8ff; }
    .meta-row { display:flex; justify-content:space-between; gap:8px; align-items:center; }
    .badge { padding:4px 8px; border-radius: 6px; background: rgba(255,255,255,0.06); font-size:12px; }
    #metrics { margin-left: 12px; font-size:13px; color:#cfe8ff; }
  /* AppsGeyser color override - paste this at the END of your existing <style> block */
  html, body {
    height: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
    background: #081a2b !important;
    color: #ffffff !important;
    -webkit-text-size-adjust: 100% !important;
  }
  header { background: #03101f !important; color: #FFD700 !important; }
  header h1 { color: #FFD700 !important; }
  .panel { background: transparent !important; color: #ffffff !important; }
  .game-box { background: #12345a !important; border-radius: 10px !important; box-shadow: none !important; color: #ffffff !important; }
  #multiplier { color: #ffffff !important; }
  input, .modal-content input { background: #0b1b33 !important; color: #ffffff !important; border: 1px solid rgba(255,255,255,0.12) !important; }
  button, .controls button { color: inherit !important; border: none !important; }
  .primary { background: #FFD700 !important; color: #000 !important; font-weight: 700 !important; }
  .danger  { background: #d7263d !important; color: #fff !important; }
  .modal { background: rgba(0,0,0,0.8) !important; }
  .modal-content { background: #0c223a !important; color: #ffffff !important; border: 1px solid rgba(255,255,255,0.06) !important; }
  #userInfo, #username, #balance { color: #ffffff !important; }
  </style>
  <meta name="theme-color" content="#03101f">
</head>
<body>

<header>
  <h1>‚úàÔ∏è Ka Ndeke</h1>
  <div class="right">
    <div id="metrics" title="Live aggregate metrics">Loading metrics...</div>
    <button id="historyBtn" class="badge" onclick="showHistory()">History</button>
    <button id="loginBtn" onclick="showLogin()">Login</button>
    <button id="registerBtn" onclick="showRegister()">Register</button>
    <button id="logoutBtn" onclick="logout()" class="hidden">Logout</button>
    <button id="guestBtn" onclick="useGuest()">Guest</button>
  </div>
</header>

<div class="panel">
  <div id="userInfo">Logged in as: <b id="username">Guest</b><br />Balance: <b>ZMW <span id="balance">10.00</span></b></div>
</div>

<div class="game-box">
  <div id="multiplier">1.00x</div>
  <svg id="plane" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
    <path d="M4 18 C18 18 32 16 46 12 C50 11 54 9 60 8 L58 6 C52 7 48 9 44 10 C30 14 18 16 6 18 Z" fill="#FFD54F"/>
    <path d="M18 18 L36 10 L40 12 L24 20 Z" fill="#FF7043"/>
    <path d="M22 20 L38 22 L36 24 L20 22 Z" fill="#FF7043"/>
    <path d="M6 18 L2 14 L2 18 Z" fill="#FF7043"/>
    <circle cx="46" cy="11" r="2.2" fill="rgba(0,0,0,0.6)"/>
    <path d="M4 18 C18 18 32 16 46 12 C50 11 54 9 60 8" fill="none" stroke="rgba(0,0,0,0.06)" stroke-width="1"/>
  </svg>
</div>

<div class="controls">
  <input type="number" id="betAmount" value="5" min="1" />
  <br /><br />
  <button class="primary" onclick="startGame()">Play</button>
  <button id="cashOutBtn" class="danger" onclick="cashOut()" disabled>Cash Out</button>
  <br /><br />
  <button onclick="deposit()">Deposit ZMW</button>
  <button onclick="withdraw()">Withdraw ZMW</button>
</div>

<!-- Login Modal -->
<div class="modal" id="loginModal">
  <div class="modal-content">
    <h3>Login</h3>
    <input id="loginPhone" placeholder="Phone number" />
    <input id="loginPassword" type="password" placeholder="Password" />
    <div class="flex">
      <button class="primary" onclick="login()">Submit</button>
      <button onclick="hideModals()">Cancel</button>
    </div>
  </div>
</div>

<!-- Register Modal -->
<div class="modal" id="registerModal">
  <div class="modal-content">
    <h3>Register</h3>
    <input id="regName" placeholder="Full name" />
    <input id="regPhone" placeholder="Phone number" />
    <input id="regPassword" type="password" placeholder="Password" />
    <div class="flex">
      <button class="primary" onclick="register()">Submit</button>
      <button onclick="hideModals()">Cancel</button>
    </div>
  </div>
</div>

<!-- History Modal -->
<div class="modal" id="historyModal">
  <div class="modal-content">
    <h3>Recent Rounds <span class="small" id="historyHint"></span></h3>
    <div id="historyContainer" class="history-list">
      <!-- Filled dynamically -->
    </div>
    <div style="margin-top:8px;" class="flex">
      <button onclick="loadHistory()">Refresh</button>
      <button onclick="hideHistory()">Close</button>
    </div>
  </div>
</div>

<!-- Round Detail Modal -->
<div class="modal" id="roundModal">
  <div class="modal-content" id="roundContent">
    <h3 id="roundTitle">Round</h3>
    <div id="roundBody">
      <!-- Filled dynamically -->
    </div>
    <div style="margin-top:8px;" class="flex">
      <button onclick="closeRound()">Close</button>
    </div>
  </div>
</div>

<script>
/* GLOBAL HELPERS */
const API = "https://ka-ndeke-backend-5dgy.onrender.com/api"; // backend base (keep as your backend URL)
let user = { guest: true };
let balance = Number(localStorage.getItem("guest_balance") || 10);
let running = false;
let currentBet = 0;
let roundCrashed = false;
let currentRoundId = null;
let statusPoller = null;
let spectatorPoller = null;

/* UI helpers */
function updateUI() {
  document.getElementById("username").textContent = user.guest ? "Guest" : (user.username || user.name || "User");
  document.getElementById("balance").textContent = Number(balance || 0).toFixed(2);
  if (user.guest) {
    logoutBtn.classList.add("hidden");
    loginBtn.classList.remove("hidden");
    registerBtn.classList.remove("hidden");
    guestBtn.classList.remove("hidden");
  } else {
    logoutBtn.classList.remove("hidden");
    loginBtn.classList.add("hidden");
    registerBtn.classList.add("hidden");
    guestBtn.classList.add("hidden");
  }
}
updateUI();

function showLogin() { loginModal.style.display = "flex"; }
function showRegister() { registerModal.style.display = "flex"; }
function hideModals() { loginModal.style.display = "none"; registerModal.style.display = "none"; }
function showHistory() { document.getElementById('historyModal').style.display = 'flex'; loadHistory(); }
function hideHistory() { document.getElementById('historyModal').style.display = 'none'; }
function showRoundModal() { document.getElementById('roundModal').style.display = 'flex'; }
function closeRound() { document.getElementById('roundModal').style.display = 'none'; }

/* Multiplier and plane rendering */
function renderMultiplierAndPlane(mult) {
  const m = Number(Number(mult || 1).toFixed(2));
  const multEl = document.getElementById("multiplier");
  const planeEl = document.getElementById("plane");
  if (multEl) multEl.textContent = m.toFixed(2) + "x";
  if (planeEl) {
    const x = m * 15;
    const y = m * -6;
    planeEl.style.transform = `translate(${x}px, ${y}px)`;
  }
}

/* Spectator poll */
function startSpectatorPoll(intervalMs = 200) {
  if (spectatorPoller) return;
  spectatorPoller = setInterval(async () => {
    try {
      if (running) { stopSpectatorPoll(); return; }
      const res = await fetch(`${API}/game/status`);
      if (!res.ok) return;
      const data = await res.json().catch(()=>null);
      if (!data) return;
      let liveMult = 1;
      if (data.startedAt) {
        const elapsedMs = Date.now() - Number(data.startedAt);
        liveMult = 1 + (elapsedMs / 1000) * 1;
      } else if (data.multiplier) {
        liveMult = Number(data.multiplier);
      }
      if (data.status === "crashed") {
        renderMultiplierAndPlane(data.multiplier ?? data.crashPoint ?? 1);
        return;
      }
      renderMultiplierAndPlane(liveMult);
    } catch (e) {
      console.warn("spectator poll error", e);
    }
  }, intervalMs);
}
function stopSpectatorPoll() { if (spectatorPoller) { clearInterval(spectatorPoller); spectatorPoller = null; } }
startSpectatorPoll();

/* GAME / API helpers (auth header included when token exists) */
function authHeaders() {
  const token = localStorage.getItem("token");
  const headers = { "Content-Type": "application/json" };
  if (token) headers["Authorization"] = "Bearer " + token;
  return headers;
}

/* START GAME */
async function startGame() {
  if (running) return;
  const bet = Number(document.getElementById("betAmount").value);
  if (!bet || isNaN(bet) || bet <= 0) return alert("Invalid bet amount");

  try {
    const res = await fetch(API + "/game/start", {
      method: "POST",
      headers: authHeaders(),
      body: JSON.stringify({ betAmount: bet })
    });

    const data = await res.json().catch(()=>({}));
    if (!res.ok) {
      return alert(data.error || "Failed to start round");
    }

    if (data.balance !== undefined) { balance = Number(data.balance); updateUI(); }
    currentRoundId = data.roundId;
    currentBet = bet;
    roundCrashed = false;
    running = true;
    updateUI();

    if (statusPoller) { clearInterval(statusPoller); statusPoller = null; }
    statusPoller = setInterval(async () => {
      try {
        const res = await fetch(`${API}/game/status`);
        if (!res.ok) return;
        const d = await res.json().catch(()=>null);
        if (!d) return;
        let liveMult = 1;
        if (d.startedAt) {
          const elapsedMs = Date.now() - Number(d.startedAt);
          liveMult = 1 + (elapsedMs / 1000) * 1;
        } else if (d.multiplier) {
          liveMult = Number(d.multiplier);
        }
        if (!running) return;
        if (d.status === "running") {
          renderMultiplierAndPlane(liveMult);
          document.getElementById("cashOutBtn").disabled = false;
        } else if (d.status === "crashed") {
          renderMultiplierAndPlane(d.multiplier ?? d.crashPoint ?? 1);
          alert("üí• CRASHED");
          running = false;
          roundCrashed = true;
          document.getElementById("cashOutBtn").disabled = true;
          currentRoundId = null;
          currentBet = 0;
          renderMultiplierAndPlane(1);
        }
      } catch (err) { console.error("player poll error", err); }
    }, 120);

  } catch (err) {
    console.error("startGame error", err);
    alert("Failed to start round: " + (err.message || err));
  }
}

/* CASH OUT */
async function cashOut() {
  if (roundCrashed) { alert("Too late ‚Äî round already crashed"); return; }
  try {
    const statusRes = await fetch(`${API}/game/status`);
    const statusData = await statusRes.json().catch(()=>({}));
    if (statusData.status === "crashed") {
      alert("Round already crashed");
      return;
    }
  } catch (e) { console.warn("status check failed", e); alert("Round status unclear. Please wait."); return; }

  if (!running) { alert("No active round"); return; }

  running = false;
  if (statusPoller) { clearInterval(statusPoller); statusPoller = null; }
  document.getElementById("cashOutBtn").disabled = true;

  try {
    const res = await fetch(API + "/game/cashout", {
      method: "POST",
      headers: authHeaders(),
      body: JSON.stringify({})
    });
    const data = await res.json().catch(()=>({}));
    if (!res.ok) throw new Error(data.error || "Cash out failed");

    if (data.balance !== undefined) {
      balance = Number(data.balance);
      updateUI();
    }

    if (data.win) {
      alert("You won ZMW " + Number(data.payout).toFixed(2));
    } else {
      alert("Crashed!");
    }
  } catch (err) {
    alert(err.message || "Cash out failed");
    return;
  }

  currentRoundId = null;
  currentBet = 0;
  roundCrashed = false;
  renderMultiplierAndPlane(1);
  updateUI();
}

/* AUTH */
async function refreshBalance() {
  const token = localStorage.getItem("token");
  if (!token) { console.warn("No token for refreshBalance"); return; }
  try {
    const res = await fetch(API + "/users/me", { headers: { "Authorization": "Bearer " + token } });
    const data = await res.json().catch(()=>({}));
    if (res.ok) {
      balance = Number(data.balance ?? balance);
      user = data || user;
      updateUI();
    } else {
      console.warn("refreshBalance non-ok", data);
    }
  } catch (err) { console.error("refreshBalance error", err); }
}

async function login() {
  if (!loginPhone.value || !loginPassword.value) return alert("Phone and password required");
  try {
    const res = await fetch(API + "/auth/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ phone: loginPhone.value, password: loginPassword.value })
    });
    const data = await res.json().catch(()=>({}));
    if (!res.ok) throw new Error(data.error || "Login failed");
    localStorage.setItem("token", data.token);
    user = data.user ?? { guest: false };
    balance = Number(data.user?.balance ?? data.balance ?? balance);
    hideModals();
    updateUI();
    fetchPublicMetrics();
  } catch (err) { alert(err.message || "Login failed"); }
}

async function register() {
  if (!regName.value || !regPhone.value || !regPassword.value) return alert("Username, phone and password required");
  try {
    const res = await fetch(API + "/auth/register", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username: regName.value, phone: regPhone.value, password: regPassword.value })
    });
    const data = await res.json().catch(()=>({}));
    if (!res.ok) throw new Error(data.error || "Register failed");
    localStorage.setItem("token", data.token);
    user = data.user ?? { guest: false };
    balance = Number(data.user?.balance ?? data.balance ?? balance);
    hideModals();
    updateUI();
    fetchPublicMetrics();
  } catch (err) { alert(err.message || "Register failed"); }
}

function logout() {
  user = { guest: true };
  const stored = localStorage.getItem("guest_balance");
  balance = stored !== null ? Number(stored) : 10;
  localStorage.removeItem("token");
  updateUI();
  fetchPublicMetrics();
}

/* GUEST MODE */
function useGuest() {
  user = { guest: true };
  const stored = localStorage.getItem("guest_balance");
  balance = stored !== null ? Number(stored) : 10;
  updateUI();
}

/* WALLET */
async function deposit() {
  const amt = prompt("Enter deposit amount");
  if (!amt || isNaN(amt) || amt <= 0) return alert("Invalid amount");
  if (user.guest) {
    balance += Number(amt);
    localStorage.setItem("guest_balance", balance);
    updateUI();
    alert("Deposit succeeded (guest)");
    return;
  }
  const token = localStorage.getItem("token");
  if (!token) return alert("You must be logged in to deposit");
  try {
    const res = await fetch(API + "/users/deposit", {
      method: "POST",
      headers: { "Content-Type": "application/json", "Authorization": "Bearer " + token },
      body: JSON.stringify({ amount: Number(amt) })
    });
    const data = await res.json().catch(()=>({}));
    if (!res.ok) return alert(data.error || `Deposit failed (HTTP ${res.status})`);
    if (data.balance !== undefined) { balance = Number(data.balance); user = data; updateUI(); } else await refreshBalance();
    alert("Deposit succeeded");
    fetchPublicMetrics();
  } catch (err) { console.error("deposit error", err); alert("Network error during deposit"); }
}

async function withdraw() {
  const amt = prompt("Enter withdraw amount");
  if (!amt || isNaN(amt) || amt <= 0) return alert("Invalid amount");
  if (user.guest) {
    if (amt > balance) return alert("Insufficient balance");
    balance -= Number(amt);
    localStorage.setItem("guest_balance", balance);
    updateUI();
    alert("Withdraw succeeded (guest)");
    return;
  }
  const token = localStorage.getItem("token");
  if (!token) return alert("You must be logged in to withdraw");
  try {
    const res = await fetch(API + "/users/withdraw", {
      method: "POST",
      headers: { "Content-Type": "application/json", "Authorization": "Bearer " + token },
      body: JSON.stringify({ amount: Number(amt) })
    });
    const data = await res.json().catch(()=>({}));
    if (!res.ok) return alert(data.error || `Withdraw failed (HTTP ${res.status})`);
    if (data.balance !== undefined) { balance = Number(data.balance); user = data; updateUI(); } else await refreshBalance();
    alert("Withdraw succeeded");
    fetchPublicMetrics();
  } catch (err) { console.error("withdraw error", err); alert("Network error during withdraw"); }
}

/* ------------------ History UI & API ------------------ */
async function loadHistory(limit = 20) {
  try {
    document.getElementById('historyHint').textContent = 'Loading...';
    const res = await fetch(`${API}/game/history?limit=${limit}`);
    const data = await res.json().catch(()=>null);
    const container = document.getElementById('historyContainer');
    container.innerHTML = '';
    if (!res.ok || !data || !Array.isArray(data.rounds)) {
      container.innerHTML = '<div class="small">Unable to load history</div>';
      document.getElementById('historyHint').textContent = '';
      return;
    }
    if (!data.rounds.length) {
      container.innerHTML = '<div class="small">No rounds recorded yet</div>';
      document.getElementById('historyHint').textContent = '';
      return;
    }
    data.rounds.forEach(r => {
      const el = document.createElement('div');
      el.className = 'history-item';
      const started = r.started_at ? new Date(r.started_at).toLocaleString() : 'n/a';
      const crash = r.crash_point ? Number(r.crash_point).toFixed(2) + 'x' : 'running';
      el.innerHTML = `<div class="meta-row"><strong>${r.round_id.slice(0,8)}</strong><span class="badge">${crash}</span></div><div class="small">${started}</div>`;
      el.onclick = () => showRoundDetails(r.round_id);
      container.appendChild(el);
    });
    document.getElementById('historyHint').textContent = `${data.rounds.length} rounds`;
  } catch (err) {
    console.error("loadHistory error", err);
    document.getElementById('historyHint').textContent = '';
    document.getElementById('historyContainer').innerHTML = '<div class="small">Error loading history</div>';
  }
}

async function showRoundDetails(roundId) {
  try {
    document.getElementById('roundTitle').textContent = 'Round ' + roundId.slice(0,12);
    document.getElementById('roundBody').innerHTML = '<div class="small">Loading...</div>';
    showRoundModal();
    const res = await fetch(`${API}/game/rounds/${encodeURIComponent(roundId)}`);
    const data = await res.json().catch(()=>null);
    if (!res.ok || !data.round) {
      document.getElementById('roundBody').innerHTML = '<div class="small">Unable to load round details</div>';
      return;
    }
    const r = data.round;
    const bets = data.bets || [];
    const started = r.started_at ? new Date(r.started_at).toLocaleString() : 'n/a';
    const ended = r.ended_at ? new Date(r.ended_at).toLocaleString() : 'n/a';
    let html = `<div class="small"><b>Started:</b> ${started}<br/><b>Ended:</b> ${ended}<br/><b>Crash:</b> ${r.crash_point ?? 'running'}</div>`;
    html += `<h4 style="margin-top:8px;">Bets (${bets.length})</h4>`;
    if (!bets.length) html += '<div class="small">No bets recorded for this round</div>';
    else {
      html += '<div class="small">';
      bets.forEach(b => {
        html += `<div style="padding:6px;border-bottom:1px solid rgba(255,255,255,0.03);"><strong>${b.user_id ? b.user_id.slice(0,8) : 'guest'}</strong> - ${Number(b.bet_amount).toFixed(2)} ZMW <span class="small">(${b.status})</span>`;
        if (b.payout !== null && b.payout !== undefined) html += `<div class="small">payout: ${Number(b.payout).toFixed(2)}</div>`;
        html += '</div>';
      });
      html += '</div>';
    }
    document.getElementById('roundBody').innerHTML = html;
  } catch (err) {
    console.error("showRoundDetails error", err);
    document.getElementById('roundBody').innerHTML = '<div class="small">Error loading details</div>';
  }
}

/* Public metrics fetch (display in header) */
async function fetchPublicMetrics() {
  try {
    const res = await fetch(`${API}/metrics/public`);
    const m = await res.json().catch(()=>null);
    if (res.ok && m) {
      document.getElementById('metrics').textContent = `Bets:${m.totalBets} Vol:${m.totalVolume} Payouts:${m.totalPayouts}`;
    } else {
      document.getElementById('metrics').textContent = '';
    }
  } catch (e) {
    document.getElementById('metrics').textContent = '';
  }
}
fetchPublicMetrics();
setInterval(fetchPublicMetrics, 60_000);

/* Small UX: hide modals on background click */
document.querySelectorAll('.modal').forEach(m => {
  m.addEventListener('click', (ev) => { if (ev.target === m) m.style.display = 'none'; });
});

</script>

</body>
</html>
