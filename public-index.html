<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Ka Ndeke ‚Äì Accounts & Crash Game</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* --- Layout & theme --- */
    body{
      margin:0;
      font-family: Arial, sans-serif;
      background:#0b1c2d;
      color:#fff;
      text-align:center;
    }

    .header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:10px;
      background:#081421;
      gap:12px;
    }

    .header h2{margin:0;color:#f7c600}

    .header .auth button{
      margin-left:5px;
      padding:6px 10px;
    }

    .backend-config {
      display:flex;
      gap:8px;
      align-items:center;
    }

    .backend-config input {
      padding:6px;
      border-radius:4px;
      border:1px solid #234;
      background:#072033;
      color:#fff;
      width:220px;
    }
    .backend-config button { padding:6px 8px; }

    .balance{
      padding:10px;
      font-size:18px;
      background:#081421;
    }

    .game{
      padding:10px;
      max-width:740px;
      margin:20px auto;
    }

    .sky{
      position:relative;
      height:280px;
      background:linear-gradient(#1e3c72,#2a5298);
      overflow:hidden;
      border-radius:10px;
    }

    #plane{
      position:absolute;
      bottom:10px;
      left:50%;
      transform:translateX(-50%);
      font-size:40px;
    }

    #multiplier{
      position:absolute;
      top:10px;
      left:10px;
      font-size:22px;
      font-weight:bold;
    }

    .controls{
      margin-top:15px;
    }

    .controls input{
      padding:8px;
      width:140px;
    }

    .controls button{
      padding:8px 12px;
      margin:5px;
    }

    #status{
      margin-top:10px;
      font-weight:bold;
    }

    .demo{
      font-size:12px;
      opacity:0.8;
      margin-top:5px;
    }

    /* deposit/withdraw compact area */
    .wallet-controls {
      margin-top:12px;
      display:flex;
      gap:8px;
      justify-content:center;
      flex-wrap:wrap;
    }
    .wallet-controls input { width:140px; padding:6px; }

    /* simple modal for forms */
    .modal-backdrop {
      display:none;
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.6);
      justify-content:center;
      align-items:center;
      z-index:1000;
    }
    .modal {
      background:#0b2035;
      padding:16px;
      border-radius:8px;
      width:320px;
      box-shadow:0 6px 18px rgba(0,0,0,0.6);
      text-align:left;
    }
    .modal h3{margin-top:0;color:#f7c600}
    .modal label{display:block;margin-top:8px;font-size:14px}
    .modal input{width:100%;padding:8px;margin-top:4px;border-radius:4px;border:1px solid #234}
    .modal .row{display:flex;gap:8px;margin-top:12px;justify-content:flex-end}
    .small { font-size:12px; color:#bbb; margin-top:6px; display:block;}
    .error { color:#ff7b7b; margin-top:8px; font-size:13px;}
    .success { color:#7bffb6; margin-top:8px; font-size:13px;}
    .status-badge { font-size:12px; padding:4px 8px; border-radius:6px; background:#072033; color:#9fd6ff; margin-left:8px;}
    @media (max-width:420px){ .modal{width:92%} .controls input{width:100px} .wallet-controls{flex-direction:column} .backend-config input{width:140px} }
  </style>
</head>
<body>
  <div class="header">
    <h2>‚úàÔ∏è Ka Ndeke</h2>

    <div style="display:flex;align-items:center;gap:12px;">
      <div class="backend-config">
        <input id="backendUrlInput" type="text" placeholder="Backend Host or API base (optional)" />
        <button id="setBackendBtn">Set</button>
        <div id="apiStatus" class="status-badge">API: auto</div>
      </div>

      <div class="auth">
        <button id="loginBtn">Login</button>
        <button id="registerBtn">Register</button>
        <button id="logoutBtn" style="display:none">Logout</button>
      </div>
    </div>
  </div>

  <div class="balance">
    Logged in as: <strong id="username">Guest</strong><br>
    Balance: <strong id="balance">K 10.00</strong><br>
    <small id="freeRounds"></small>
    <div class="small">Deposits/withdrawals use the server when available. If no server is set or unreachable the app will work in offline/local mode and store accounts on the device.</div>
  </div>

  <div class="game">
    <div class="sky">
      <div id="multiplier">1.00x</div>
      <div id="plane">‚úàÔ∏è</div>
    </div>

    <!-- Controls (now above wallet controls) -->
    <div class="controls">
      <input type="number" id="betAmount" placeholder="Bet (K)" />
      <br />
      <button id="betBtn">Place Bet</button>
      <button id="cashOutBtn" disabled>Cash Out</button>

      <!-- Deposit/Withdraw moved under the controls -->
      <div class="wallet-controls" style="margin-top:12px;">
        <input type="number" id="depositAmount" placeholder="Deposit amount" />
        <button id="depositBtn">Deposit</button>
        <input type="number" id="withdrawAmount" placeholder="Withdraw amount" />
        <button id="withdrawBtn">Withdraw</button>
      </div>
    </div>

    <div id="status"></div>

    <div class="demo">Real accounts supported. Guests get K10 to play.</div>
  </div>

  <!-- Modal: Register / Login (Full name + Phone + Password) -->
  <div id="modalBackdrop" class="modal-backdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <h3 id="modalTitle">Login</h3>

      <form id="authForm">
        <div id="fullnameRow" style="display:none;">
          <label for="modalFullname">Full name</label>
          <input id="modalFullname" name="fullname" autocomplete="name" />
        </div>

        <label for="modalPhone">Phone number</label>
        <input id="modalPhone" name="phone" type="tel" autocomplete="tel" placeholder="+2507..." />

        <label for="modalPassword">Password</label>
        <input id="modalPassword" name="password" type="password" autocomplete="current-password" />

        <div class="row">
          <button type="button" id="modalCancel">Cancel</button>
          <button type="submit" id="modalSubmit">Submit</button>
        </div>
        <div id="modalMessage" class=""></div>
      </form>
    </div>
  </div>

  <script>
  // Full client-side logic (integrated). Phone-based auth, API auto-detect, offline fallback, health probe.
  document.addEventListener('DOMContentLoaded', () => {
    // Config & keys
    let API_BASE = '/api'; // default when served from same host
    const TOKEN_KEY = 'token';
    const LOCAL_USERS_KEY = 'localUsers_phone';
    const LOCAL_CURRENT_KEY = 'localCurrent_phone';
    const guestDefaultBalance = 10;

    // DOM refs
    const backendUrlInput = document.getElementById('backendUrlInput');
    const setBackendBtn = document.getElementById('setBackendBtn');
    const apiStatusEl = document.getElementById('apiStatus');

    const loginBtn = document.getElementById('loginBtn');
    const registerBtn = document.getElementById('registerBtn');
    const logoutBtn = document.getElementById('logoutBtn');

    const usernameEl = document.getElementById('username');
    const balanceEl = document.getElementById('balance');
    const freeRoundsEl = document.getElementById('freeRounds');

    const depositInput = document.getElementById('depositAmount');
    const depositBtn = document.getElementById('depositBtn');
    const withdrawInput = document.getElementById('withdrawAmount');
    const withdrawBtn = document.getElementById('withdrawBtn');

    const betAmountInput = document.getElementById('betAmount');
    const betBtn = document.getElementById('betBtn');
    const cashOutBtn = document.getElementById('cashOutBtn');
    const statusEl = document.getElementById('status');

    const modalBackdrop = document.getElementById('modalBackdrop');
    const modalTitle = document.getElementById('modalTitle');
    const fullnameRow = document.getElementById('fullnameRow');
    const modalFullname = document.getElementById('modalFullname');
    const modalPhone = document.getElementById('modalPhone');
    const modalPassword = document.getElementById('modalPassword');
    const modalSubmit = document.getElementById('modalSubmit');
    const modalCancel = document.getElementById('modalCancel');
    const modalMessage = document.getElementById('modalMessage');
    const authForm = document.getElementById('authForm');

    // Local helpers
    function saveLocalUsers(obj) { try { localStorage.setItem(LOCAL_USERS_KEY, JSON.stringify(obj || {})); } catch(e){} }
    function loadLocalUsers() { try { return JSON.parse(localStorage.getItem(LOCAL_USERS_KEY) || '{}'); } catch(e){ return {}; } }
    function setLocalCurrent(phone) { try { localStorage.setItem(LOCAL_CURRENT_KEY, phone || ''); } catch(e){} }
    function getLocalCurrent() { try { return localStorage.getItem(LOCAL_CURRENT_KEY) || ''; } catch(e){ return ''; } }
    function uuidv4() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c){ const r = Math.random()*16|0, v = c=='x' ? r : (r&0x3|0x8); return v.toString(16); }); }

    function setApiStatus(text, color) { apiStatusEl.textContent = text; apiStatusEl.style.background = color || '#072033'; }

    // ---------- Network helpers ----------
    async function apiFetch(path, opts = {}, withAuth = true) {
      const base = (API_BASE || '/api').replace(/\/+$/, '');
      const relPath = (path || '').replace(/^\/+/, '');
      const url = base + '/' + relPath;

      const headers = opts.headers || {};
      if (withAuth) {
        const token = localStorage.getItem(TOKEN_KEY);
        if (token) headers['Authorization'] = 'Bearer ' + token;
      }
      opts.headers = headers;

      console.log(`[API] ${opts.method || 'GET'} ${url}`, opts);

      let res;
      try {
        res = await fetch(url, opts);
      } catch (err) {
        console.error('[API] network error', err);
        throw new Error('Network error: could not reach ' + url);
      }

      const status = res.status;
      const text = await res.text();
      let json = null;
      try { json = text ? JSON.parse(text) : null; } catch (e) { json = null; }

      console.log(`[API] response ${status} ${url}`, { text: text.slice(0,2000), json });

      if (!res.ok) {
        if (json && json.error) throw new Error(json.error);
        if (text && /<html|<!doctype/i.test(text)) throw new Error(`Server returned HTML error (status ${status})`);
        throw new Error(text || `Request failed (${status})`);
      }
      return json;
    }

    async function tryApi(path, opts = {}, withAuth = true) {
      try {
        const data = await apiFetch(path, opts, withAuth);
        return { ok: true, data };
      } catch (err) {
        const msg = (err && err.message) ? err.message : String(err);
        const isNetwork = /network|could not reach|failed to fetch/i.test(msg);
        return { ok: false, network: isNetwork, error: err };
      }
    }

    // ---------- Health probe + auto-detect API base ----------
    function withProtocol(u) {
      if (/^https?:\/\//i.test(u)) return u;
      return 'https://' + u;
    }
    function buildCandidates(raw) {
      if (!raw) return ['/api'];
      let val = withProtocol(raw.trim()).replace(/\/+$/, '');
      const candidates = new Set();
      if (/\/api(\/|$)/i.test(val)) {
        candidates.add(val);
        candidates.add(val.replace(/\/api\/?$/i, ''));
      } else {
        candidates.add(val + '/api');
        candidates.add(val);
      }
      if (!/^http:\/\//i.test(val)) {
        candidates.add(val.replace(/^https:\/\//i, 'http://') + '/api');
        candidates.add(val.replace(/^https:\/\//i, 'http://'));
      }
      return Array.from(candidates);
    }

    async function probeAndSetApiBase(rawInput) {
      const candidates = buildCandidates(rawInput);
      setApiStatus('API: testing...', '#444');
      for (const c of candidates) {
        try {
          const base = c.replace(/\/+$/, '');
          const healthUrl = base + '/health';
          console.log('[API] probing', healthUrl);
          const res = await fetch(healthUrl, { method: 'GET' });
          if (res.ok) {
            if (/\/api(\/|$)/i.test(base)) {
              API_BASE = base.replace(/\/+$/, '');
              setApiStatus('API: set (reachable)', '#083a1f');
              console.log('[API] selected base', API_BASE);
              return { ok: true, base: API_BASE };
            } else {
              const candidateApi = base + '/api';
              try {
                const res2 = await fetch(candidateApi + '/health', { method: 'GET' });
                if (res2.ok) {
                  API_BASE = candidateApi;
                  setApiStatus('API: set (reachable)', '#083a1f');
                  console.log('[API] selected base', API_BASE);
                  return { ok: true, base: API_BASE };
                }
              } catch (e) {
                // fall through and accept base
              }
              API_BASE = base;
              setApiStatus('API: set (reachable)', '#083a1f');
              console.log('[API] selected base (fallback)', API_BASE);
              return { ok: true, base: API_BASE };
            }
          } else {
            console.log('[API] probe non-ok', healthUrl, res.status);
          }
        } catch (err) {
          console.log('[API] probe failed', c, err && err.message);
        }
      }
      setApiStatus('API: unreachable', '#663300');
      return { ok: false };
    }

    // ---------- Server API (phone-based) ----------
    async function registerServer(fullname, phone, password) {
      return await tryApi('/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username: fullname, phone, password })
      }, false);
    }
    async function loginServer(phone, password) {
      return await tryApi('/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ phone, password })
      }, false);
    }
    async function getMe() { return await tryApi('/users/me', { method: 'GET' }, true); }
    async function depositServer(amount) { return await tryApi('/users/deposit', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ amount }) }, true); }
    async function withdrawServer(amount) { return await tryApi('/users/withdraw', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ amount }) }, true); }
    async function changeBalanceServer(delta) { return await tryApi('/users/balance/change', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ delta }) }, true); }

    // ---------- Local fallback ----------
    function localRegister(fullname, phone, password) {
      const users = loadLocalUsers();
      if (users[phone]) throw new Error('Phone already registered locally');
      const id = uuidv4();
      const now = new Date().toISOString();
      users[phone] = { id, username: fullname, phone, password, balance: guestDefaultBalance, freeRounds: 0, createdAt: now, updatedAt: now };
      saveLocalUsers(users);
      setLocalCurrent(phone);
      authMode = 'local';
      currentUser = users[phone];
      localStorage.removeItem(TOKEN_KEY);
      return users[phone];
    }
    function localLogin(phone, password) {
      const users = loadLocalUsers();
      const u = users[phone];
      if (!u) throw new Error('Local account not found');
      if (u.password !== password) throw new Error('Invalid credentials (local)');
      setLocalCurrent(phone);
      authMode = 'local';
      currentUser = u;
      localStorage.removeItem(TOKEN_KEY);
      return u;
    }
    function localApplyChange(delta) {
      const phone = getLocalCurrent();
      const users = loadLocalUsers();
      const u = users[phone];
      if (!u) throw new Error('No local account');
      const updated = Number(u.balance || 0) + Number(delta);
      if (updated < 0) throw new Error('Insufficient funds (local)');
      u.balance = updated;
      u.updatedAt = new Date().toISOString();
      saveLocalUsers(users);
      currentUser = u;
      return u;
    }

    // ---------- UI helpers ----------
    function applyUserToUI(user, mode) {
      if (!user) return;
      currentUser = user;
      authMode = mode || authMode;
      usernameEl.textContent = (user.username || user.phone || 'Player') + (authMode === 'local' ? ' (offline)' : '');
      const newBalance = Number(user.balance || 0);
      balanceEl.textContent = 'K ' + Number(newBalance).toFixed(2);
      freeRoundsEl.textContent = user.freeRounds ? 'Free rounds: ' + user.freeRounds : '';
      loginBtn.style.display = authMode ? 'none' : '';
      registerBtn.style.display = authMode ? 'none' : '';
      logoutBtn.style.display = authMode ? '' : 'none';
    }
    function clearToGuest() {
      authMode = null;
      currentUser = null;
      usernameEl.textContent = 'Guest';
      balanceEl.textContent = 'K ' + Number(guestDefaultBalance).toFixed(2);
      freeRoundsEl.textContent = '';
      loginBtn.style.display = '';
      registerBtn.style.display = '';
      logoutBtn.style.display = 'none';
    }
    function updateGuestUI() {
      usernameEl.textContent = 'Guest';
      balanceEl.textContent = 'K ' + Number(guestDefaultBalance).toFixed(2);
      freeRoundsEl.textContent = '';
    }

    // ---------- Modal handling ----------
    function showModal(mode) {
      modalMessage.textContent = '';
      modalMessage.className = '';
      if (mode === 'login') {
        modalTitle.textContent = 'Login';
        if (fullnameRow) fullnameRow.style.display = 'none';
        if (modalFullname) modalFullname.value = '';
        modalPhone.value = '';
        modalPassword.value = '';
        modalSubmit.textContent = 'Login';
      } else {
        modalTitle.textContent = 'Register';
        if (fullnameRow) fullnameRow.style.display = '';
        if (modalFullname) modalFullname.value = '';
        modalPhone.value = '';
        modalPassword.value = '';
        modalSubmit.textContent = 'Register';
      }
      modalBackdrop.style.display = 'flex';
      modalBackdrop.setAttribute('aria-hidden','false');
      modalPhone.focus();
    }
    function hideModal() {
      modalBackdrop.style.display = 'none';
      modalBackdrop.setAttribute('aria-hidden','true');
    }
    if (modalCancel) modalCancel.addEventListener('click', (e) => { e.preventDefault(); hideModal(); });

    // ---------- Register/login flows with fallback ----------
    async function registerFlow(fullname, phone, password) {
      try {
        const serverResp = await registerServer(fullname, phone, password);
        if (serverResp.ok && serverResp.data) {
          localStorage.setItem(TOKEN_KEY, serverResp.data.token);
          return { user: serverResp.data.user, token: serverResp.data.token };
        }
        if (serverResp.network) {
          const localUser = localRegister(fullname, phone, password);
          return { user: localUser };
        }
        throw serverResp.error || new Error('Registration failed');
      } catch (err) {
        throw err;
      }
    }
    async function loginFlow(phone, password) {
      try {
        const serverResp = await loginServer(phone, password);
        if (serverResp.ok && serverResp.data) {
          localStorage.setItem(TOKEN_KEY, serverResp.data.token);
          return { payload: serverResp.data };
        }
        if (serverResp.network) {
          const localUser = localLogin(phone, password);
          return { user: localUser };
        }
        throw serverResp.error || new Error('Login failed');
      } catch (err) {
        throw err;
      }
    }

    // ---------- Auth form submit ----------
    if (authForm) {
      authForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        modalMessage.textContent = '';
        modalMessage.className = '';
        const isRegister = modalTitle.textContent.toLowerCase().includes('register');
        const phone = modalPhone.value && modalPhone.value.trim();
        const password = modalPassword.value;
        const fullname = modalFullname && modalFullname.value && modalFullname.value.trim();

        if (!phone || !password || (isRegister && !fullname)) {
          modalMessage.textContent = 'Please fill required fields';
          modalMessage.className = 'error';
          return;
        }

        modalSubmit.disabled = true;
        try {
          if (isRegister) {
            const res = await registerFlow(fullname, phone, password);
            if (res && res.user) {
              applyUserToUI(res.user, res.token ? 'server' : 'local');
              modalMessage.textContent = 'Registered and logged in';
              modalMessage.className = 'success';
              setTimeout(hideModal, 700);
            }
          } else {
            const res = await loginFlow(phone, password);
            const user = res && res.payload && res.payload.user ? res.payload.user : (res.user || (res.payload && res.payload.user));
            applyUserToUI(user || currentUser, res.payload ? 'server' : 'local');
            modalMessage.textContent = 'Logged in';
            modalMessage.className = 'success';
            setTimeout(hideModal, 400);
          }
        } catch (err) {
          modalMessage.textContent = err.message || 'Auth failed';
          modalMessage.className = 'error';
        } finally {
          modalSubmit.disabled = false;
        }
      });
    }

    // ---------- Deposit / Withdraw handlers ----------
    if (depositBtn) depositBtn.addEventListener('click', async () => {
      const amount = Number(depositInput.value);
      if (!(amount > 0)) return alert('Enter deposit amount > 0');
      try {
        if (authMode === 'server') {
          const res = await depositServer(amount);
          if (res.ok) applyUserToUI(res.data, 'server');
        } else if (authMode === 'local') {
          const u = localApplyChange(amount);
          applyUserToUI(u, 'local');
        } else {
          alert('Deposit applied to guest session (not persisted). Register to persist.');
        }
      } catch (err) {
        alert('Deposit failed: ' + (err.message || ''));
      } finally {
        depositInput.value = '';
      }
    });
    if (withdrawBtn) withdrawBtn.addEventListener('click', async () => {
      const amount = Number(withdrawInput.value);
      if (!(amount > 0)) return alert('Enter withdraw amount > 0');
      try {
        if (authMode === 'server') {
          const res = await withdrawServer(amount);
          if (res.ok) applyUserToUI(res.data, 'server');
        } else if (authMode === 'local') {
          const u = localApplyChange(-amount);
          applyUserToUI(u, 'local');
        } else {
          alert('Withdraw applied to guest session (not persisted). Register to persist.');
        }
      } catch (err) {
        alert('Withdraw failed: ' + (err.message || ''));
      } finally {
        withdrawInput.value = '';
      }
    });

    // ---------- Game logic ----------
    let multiplier = 1.0;
    let bet = 0;
    let gameTimer = null;
    let crashed = false;

    if (betBtn) betBtn.addEventListener('click', async () => {
      if (gameTimer) return;
      bet = Number(betAmountInput.value);
      if (bet <= 0) return alert('Enter a valid bet');

      let usingFree = false;
      if (authMode && currentUser && currentUser.freeRounds > 0) { currentUser.freeRounds--; usingFree = true; }

      if (!usingFree) {
        if ((authMode === 'server' && Number(currentUser.balance || 0) < bet) ||
            (authMode === 'local' && Number(currentUser.balance || 0) < bet) ||
            (authMode === null && guestDefaultBalance < bet)) {
          return alert('Insufficient balance');
        }

        try {
          if (authMode === 'server') {
            const res = await changeBalanceServer(-bet);
            if (res.ok) applyUserToUI(res.data, 'server');
          } else if (authMode === 'local') {
            const u = localApplyChange(-bet);
            applyUserToUI(u, 'local');
          } else {
            const val = Number((balanceEl.textContent || 'K 10.00').replace(/[^0-9.-]+/g, '')) || guestDefaultBalance;
            const newVal = val - bet;
            balanceEl.textContent = 'K ' + Number(newVal).toFixed(2);
          }
        } catch (err) {
          return alert('Could not place bet: ' + (err.message || ''));
        }
      }

      multiplier = 1.0;
      crashed = false;
      document.getElementById('plane').style.bottom = '10px';
      document.getElementById('multiplier').innerText = '1.00x';
      statusEl.textContent = '‚úàÔ∏è Plane taking off...';
      cashOutBtn.disabled = false;

      let crashPoint = Math.random() < 0.7 ? 1.1 + Math.random()*0.6 : 2 + Math.random()*3;

      gameTimer = setInterval(()=> {
        multiplier += 0.02;
        document.getElementById('multiplier').innerText = multiplier.toFixed(2) + 'x';
        const planeEl = document.getElementById('plane');
        planeEl.style.bottom = (parseFloat(planeEl.style.bottom || 10) + 2) + 'px';
        if (multiplier >= crashPoint) crash();
      }, 100);
    });

    if (cashOutBtn) cashOutBtn.addEventListener('click', async () => {
      if (crashed) return;
      clearInterval(gameTimer);
      gameTimer = null;
      const win = bet * multiplier;
      statusEl.textContent = '‚úÖ Cashed out at ' + multiplier.toFixed(2) + 'x ‚Üí Won K ' + win.toFixed(2);
      cashOutBtn.disabled = true;

      try {
        if (authMode === 'server') {
          const res = await changeBalanceServer(win);
          if (res.ok) applyUserToUI(res.data, 'server');
        } else if (authMode === 'local') {
          const u = localApplyChange(win);
          applyUserToUI(u, 'local');
        } else {
          alert('Win applied to guest session (not persisted). Register to persist.');
        }
      } catch (err) {
        alert('Warning: could not save your win: ' + (err.message || ''));
      }
    });

    function crash() {
      clearInterval(gameTimer);
      gameTimer = null;
      crashed = true;
      statusEl.textContent = 'üí• CRASH at ' + multiplier.toFixed(2) + 'x ‚Äî You lost';
      cashOutBtn.disabled = true;
    }

    // ---------- Backend set button ----------
    if (setBackendBtn) {
      setBackendBtn.addEventListener('click', async () => {
        const raw = backendUrlInput.value && backendUrlInput.value.trim();
        if (!raw) {
          API_BASE = '/api';
          setApiStatus('API: auto', '#072033');
          return;
        }
        setApiStatus('API: testing...', '#444');
        const result = await probeAndSetApiBase(raw);
        if (!result.ok) {
          alert('Could not reach any API endpoints at that host. App will operate in offline/local mode.');
        } else {
          const token = localStorage.getItem(TOKEN_KEY);
          if (token) {
            const me = await tryApi('/users/me', { method: 'GET' }, true);
            if (me.ok) applyUserToUI(me.data, 'server');
            else setApiStatus('API: connected (auth required)', '#083a1f');
          }
        }
      });
    }

    // ---------- Login/Register button wiring ----------
    if (registerBtn) registerBtn.addEventListener('click', () => showModal('register'));
    if (loginBtn) loginBtn.addEventListener('click', () => showModal('login'));
    if (logoutBtn) logoutBtn.addEventListener('click', () => {
      localStorage.removeItem(TOKEN_KEY);
      setLocalCurrent('');
      currentUser = null;
      authMode = null;
      clearToGuest();
    });

    // ---------- Initialization ----------
    (async function init() {
      clearToGuest();

      const lc = getLocalCurrent();
      if (lc) {
        const users = loadLocalUsers();
        if (users[lc]) {
          currentUser = users[lc];
          authMode = 'local';
          applyUserToUI(currentUser, 'local');
        }
      }

      const token = localStorage.getItem(TOKEN_KEY);
      if (token) {
        const attempt = await tryApi('/users/me', { method:'GET' }, true);
        if (attempt.ok) {
          authMode = 'server';
          applyUserToUI(attempt.data, 'server');
          setApiStatus('API: connected', '#083a1f');
        } else {
          setApiStatus('API: unreachable', '#663300');
        }
      } else {
        setApiStatus('API: auto', '#072033');
      }
    })();

    // Expose helper
    window.__KaNdeke = {
      getState: () => ({ API_BASE, authMode, currentUser }),
      setApiBase: (b) => { backendUrlInput.value = b; setBackendBtn.click(); }
    };
  });
  </script>
</body>
</html>